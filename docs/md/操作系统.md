## 1.进程

1.1 什么是进程？进程是一段程序的执行过程 program in exectuion，也可以说是程序运行中的实例。



进程有大概有5个状态。
新建（new）状态，就绪状态（ready），运行状态（runing），等待状态（wait），结束状态（exit）



当操作系统为一个程序分配进程控制块(PCB)和内存空间后，进程进入新建状态.



当进程已经获取了运行所需要的资源时，进程进入就绪队列，等待cpu运行。ready 状态



当进程被cpu执行时，进入运行状态。



当进程运行过程中，需要一些io设备时，进程处于等待状态



进程结束



什么是进程上下文切换？多个进程切换过程

进行[进程切换](https://baike.baidu.com/item/进程切换)就是从正在运行的进程中收回[处理器](https://baike.baidu.com/item/处理器)，然后再使待运行进程来占用[处理器](https://baike.baidu.com/item/处理器)。

这里所说的从某个进程收回[处理器](https://baike.baidu.com/item/处理器)，实质上就是把进程存放在处理器的[寄存器](https://baike.baidu.com/item/寄存器)中的中间数据找个地方存起来，从而把处理器的[寄存器](https://baike.baidu.com/item/寄存器)腾出来让其他进程使用。那么被中止运行进程的中间数据存在何处好呢？当然这个地方应该是进程的私有[堆栈](https://baike.baidu.com/item/堆栈)。

让进程来占用处理器，实质上是把某个进程存放在私有[堆栈](https://baike.baidu.com/item/堆栈)中[寄存器](https://baike.baidu.com/item/寄存器)的数据（前一次本进程被中止时的中间数据）再恢复到处理器的寄存器中去，并把待运行进程的[断点](https://baike.baidu.com/item/断点)送入处理器的程序[指针](https://baike.baidu.com/item/指针)PC，于是待运行进程就开始被处理器运行了，也就是这个进程已经占有处理器的使用权了。



进程上下文切换

在切换时，一个进程存储在处理器各[寄存器](https://baike.baidu.com/item/寄存器)中的中间数据叫做进程的上下文，所以进程的 切换实质上就是被中止运行进程与待运行[进程上下文](https://baike.baidu.com/item/进程上下文)的切换。在进程未占用处理器时，进程 的上下文是存储在进程的私有[堆栈](https://baike.baidu.com/item/堆栈)中的。

进程上下文保存在进程的私有[堆栈](https://baike.baidu.com/item/堆栈)中的。



**阻塞唤醒**

**1.引起进程阻塞和唤醒的事件**

1）请求[系统服务](https://baike.baidu.com/item/系统服务)

当正在执行的进程请求[操作系统](https://baike.baidu.com/item/操作系统)提供服务时，由于某种原因，操作系统并不立即满足该进程的要求时，该进程只能转变为[阻塞状态](https://baike.baidu.com/item/阻塞状态)来等待，一旦要求得到满足后，进程被唤醒。

2）启动某种操作

当进程启动某种操作后，如果该进程必须在该操作完成之后才能继续执行，则必须先使该进程阻塞，以等待该操作完成，该操作完成后，将该进程唤醒。

3）新数据尚未到达

对于相互合作的进程，如果其中一个进程需要先获得另一（合作）进程提供的数据才能运行以对数据进行处理，则是要其所需数据尚未到达，该进程只有（等待）阻塞，等到数据到达后，该进程被唤醒。

4）无新工作可做

系统往往设置一些具有某特定功能的[系统进程](https://baike.baidu.com/item/系统进程)，每当这种进程完成任务后，便把自己阻塞起来以等待新任务到来，新任务到达后，该进程被唤醒。

**2.进程阻塞过程**

正在执行的进程，当发现上述某事件后，由于无法继续执行，于是进程便通过调用阻塞[原语](https://baike.baidu.com/item/原语)block()把自己阻塞。可见，进程的阻塞是进程自身的一种主动行为。进入block过程后，由于此时该进程还处于[执行状态](https://baike.baidu.com/item/执行状态)，所以应先立即停止执行，把[进程控制块](https://baike.baidu.com/item/进程控制块)中的现行状态由执行改为阻塞，并将PCB插入阻塞[队列](https://baike.baidu.com/item/队列)。如果系统中设置了因不同事件而阻塞的多个阻塞[队列](https://baike.baidu.com/item/队列)，则应将本进程插入到具有相同事件的阻塞（等待）队列。最后，转调度程序进行重新调度，将[处理机](https://baike.baidu.com/item/处理机)分配给另一就绪进程，并进行切换，亦即，保留被阻塞进程的处理机状态（在PCB中），再按新进程的PCB中的处理机状态设置CPU环境。

**3. 进程唤醒过程**

当被阻塞的进程所期待的事件出现时，如I/O完成或者其所期待的数据已经到达，则由有关进程（比如，用完并释放了该I/O设备的进程）调用唤醒原语wakeup()，将等待该事件的进程唤醒。唤醒原语执行的过程是：首先把被阻塞的进程从等待该事件的阻塞[队列](https://baike.baidu.com/item/队列)中移出，将其PCB中的现行状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中。



1.多个进程之间的数据都是隔离的。互不影响

2.进程是系统分配资源的最小单位。



## 2.**线程**

为什么有了进程，还有会有一个线程呢？

线程的引入：

因为60年代，在OS中能拥有资源和独立运行的基本单位是进程，然而随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入轻型进程；二是由于[对称多处理机](https://baike.baidu.com/item/对称多处理机/10375153)（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。

因此在80年代，出现了能独立运行的基本单位——线程（Threads）。



**线程**（英语：thread）是[操作系统](https://baike.baidu.com/item/操作系统)能够进行运算[调度](https://baike.baidu.com/item/调度)的最小单位。它被包含在[进程](https://baike.baidu.com/item/进程)之中，是[进程](https://baike.baidu.com/item/进程)中的实际运作单位。一条线程指的是[进程](https://baike.baidu.com/item/进程)中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及[SunOS](https://baike.baidu.com/item/SunOS)中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。

线程是独立调度和分派的基本单位



同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，[文件描述符](https://baike.baidu.com/item/文件描述符)和[信号处理](https://baike.baidu.com/item/信号处理)等等。但同一进程中的多个线程有各自的[调用栈](https://baike.baidu.com/item/调用栈)（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。

每个线程共享进程的数据，但也有各自的调用栈和，存储线程数据的地方。



#### go的协程 本质上也是线程，它会一般的线程有什么区别

Go的协程，通常称为`goroutines`，在本质上与传统的线程有几个显著的区别：

1. **轻量级**：`goroutines`占用的内存远少于普通的操作系统线程。通常，一个`goroutine`的堆栈大小只有几KB，而传统的线程通常需要较大的内存（如1MB）。
2. **动态栈管理**：`goroutines`的栈大小是动态的，它们可以根据需要增长和缩小，而传统线程通常有一个固定的栈大小。
3. **调度**：`goroutines`是由Go运行时内部的调度器进行管理的，而不是由操作系统直接调度。这种调度方式允许成千上万的`goroutines`在很少的OS线程上高效运行。
4. **并发模型**：Go利用`goroutines`和通道（channels）提供了一个不同于传统的锁和条件变量的并发模型。这种基于消息的模型可以简化并发程序的编写，并避免一些常见的并发问题。
5. **成本和创建速度**：创建一个`goroutine`的成本和速度通常比创建一个操作系统线程要低和快得多，这使得在需要时可以轻松创建大量的`goroutines`。

总的来说，`goroutines`是Go语言提供的一种非常高效的并发机制，通过轻量级的设计和内部调度优化，使得它们在处理高并发任务时表现出色。



#### swoole的协程和一般的线程有什么区别

Swoole 的协程是一种实现高并发的编程模型，它同样与传统的线程有一些本质的区别：

1. **轻量级**：与传统的操作系统线程相比，Swoole 协程更加轻量级。它们不是由操作系统直接调度，而是在用户空间进行调度，因此占用更少的资源。一个协程的内存消耗通常只有几十到几百KB，远小于传统线程。
2. **非阻塞和异步**：Swoole 协程可以在遇到 IO 操作时自动挂起，而不会阻塞其他协程的执行，这使得它们非常适合处理高并发的 IO 密集型应用。当 IO 操作完成后，相应的协程会被自动唤醒。
3. **成本和创建速度**：创建和切换 Swoole 协程的成本非常低，远低于传统的线程。这使得在需要处理大量并发任务时，可以高效地创建和管理大量协程。
4. **编程模型**：Swoole 协程提供了一种简化的同步编程模型，开发者可以使用传统的同步编程方式来编写代码，而底层实现则是异步非阻塞的。这大大降低了并发编程的复杂性。
5. **调度**：Swoole 协程的调度是由 Swoole 自身的调度器控制的，而不依赖于操作系统的线程调度。这种用户空间的调度策略使得协程的上下文切换非常快。

总结来说，Swoole 的协程通过轻量级设计、用户空间调度、以及简化的同步编程模型，提供了一种高效处理并发和异步任务的方法，特别适合于开发高性能的网络服务器和应用。



#### go的携程 和 swoole的携程有什么区别？



Go的协程（`goroutines`）和Swoole的协程虽然都是为了实现高效的并发编程，但它们在设计、实现和使用方式上有一些显著的区别：

1. **编程语言和环境**：
   - **Go的协程**：是Go语言的一部分，由Go语言的运行时环境管理。Go语言从设计之初就内置了协程的概念，这使得协程的使用和语言的其他部分高度整合。
   - **Swoole的协程**：是在PHP语言环境中通过Swoole扩展提供的。Swoole为PHP提供了异步编程能力，而PHP本身是同步阻塞的，所以协程是作为一个扩展来增强PHP的并发处理能力。
2. **协程的调度**：
   - **Go的协程**：由Go的运行时调度器管理，这个调度器运行在用户态，独立于操作系统的线程管理之外。Go的调度器可以在少量的操作系统线程上调度成千上万的`goroutines`。
   - **Swoole的协程**：同样由用户态的调度器管理，这意味着PHP开发者可以在单个进程中启动大量的协程，每个协程在需要进行I/O操作时挂起，直到I/O完成，调度器再将控制权交回协程。
3. **内存使用和性能**：
   - **Go的协程**：起始栈大小非常小，且可以动态地根据需要扩展或缩小栈的大小。这使得每个`goroutine`的内存占用非常低，启动速度快。
   - **Swoole的协程**：虽然也是轻量级的，但具体的内存使用情况受到PHP本身内存管理的影响。Swoole的协程也支持大量并发，每个协程的内存占用较小。
4. **适用场景和设计哲学**：
   - **Go的协程**：适用于构建高并发服务器、微服务架构以及并行处理任务。Go的协程和通道（channels）的设计哲学鼓励使用消息传递来处理并发，从而避免锁的使用和竞态条件。
   - **Swoole的协程**：主要用于提高PHP应用的并发处理能力，尤其是在网络服务器和异步任务处理方面。Swoole通过简化异步编程复杂性，并使用传统的同步风格编码来实现异步的执行效果。



## 3.线程与进程的区别

1）地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。

2）通信：[进程间通信](https://baike.baidu.com/item/进程间通信)[IPC](https://baike.baidu.com/item/IPC)，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要[进程同步](https://baike.baidu.com/item/进程同步)和互斥手段的辅助，以保证数据的一致性。

进程的通信：进程间通信主要包括管道, 系统IPC（包括[消息队列](https://baike.baidu.com/item/消息队列),信号,共享存储), 套接字(SOCKET).

3）调度和切换：线程上下文切换比进程上下文切换要快得多。

4）在多线程OS中，进程不是一个可执行的实体。

```
1.完成H项目新商户的对接，链条，测试，上线。
2.完成H项目的合约币提现功能。
3.修复与风控对接的bug
```



## 4.时间片

cpu分配给某个进程执行的时间。

进程被分配的时间片，如果时间片到了，即使进程没有执行完，也必须交出cpu。



## 5.读写效率最高的地方

获取数据时，调用cpu的寄存器是纳秒级别的，调用内存是微妙级别的，调用磁盘则是毫秒级别的。



## 6.上下文切换

上下文切换：比如A进程切换成b进程，会把a进程执行中的数据，比如打开文件资源等数据，从cpu的寄存器中复制一份到a进程的PCB的register中（保存现场）。然后再把进程b的数据，装入到cpu的寄存器。完成一次进程的切换，也称上下文切换。
a进程此时应该又被装入就绪队列，等下次执行拿出pcb中register中的数据，继续执行，称为恢复现场（reload）
