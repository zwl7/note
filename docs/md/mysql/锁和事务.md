事务在高并发下可能会造成的问题

1.脏读 ，读取到前一个事务未提交的数据。比如事务A和事务B，事务A改了张三的工资，从3000改成4000，但还没有提交，这时事务B来了，读到的张三的工资为4000，但事务A回滚了。这时就发生了脏读

2.不可重复读   读取到了其他事务修改后的数据。比如事务A第一次查询张三工资时，值为3000，此时事务B来了，将3000改成了4000，然后事务又查询了一遍，发现工资变成了4000，和第一次读到的工资不一样，此时就发生了不可重复读。不可重复读，是指在数据库访问中，一个[事务](https://baike.baidu.com/item/事务)范围内两个相同的查询却返回了不同数据

3.幻读，读到了其他事务新增会删除后的数据。比如事务A读，总资大于等于4000的人数。第一次读时，读到了1条（李四的工资为5000）。此时事务B新增了一条数据，王五的工资为5000，然后事务A又读总资大于等于4000的人数时，发现条数为2条，此时就发生了幻读。

数据库不同的隔离级别对应的不同问题

![image-20201118173354191](.\img\image-20201118173354191.png)

四种隔离级别：1未提交读，2已提交读，3可重复读，4，序列化读.





在事务中，加了排他锁的数据。如果直接在非事务中，是可以读到的。





其中在可重复读的隔离级别下，会造成幻读的情况。除了提将隔离级别提升到序列化读之外。还有什么解决方案吗？

有，在可重复读到隔离级别下，加上间隙锁可以防止幻读问题的发生。

间隙锁是如何防止幻读的发生呢？

在对数据加行锁的同时，对多条数据之间的空隙也加上间隙锁。作用就是其他事物执行插入记录的操作时，就插入不成功了。



如果加上间隙锁呢，有两个条件

1.隔离级别必须得是可重复读

2.查询时一定要走索引



默认情况下，InnoDB工作在可重复读(Repeatable Read)隔离级别下，并且会以Next-Key Lock的方式对数据行进行加锁，这样可以有效防止幻读的发生。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。 read committed隔离级别下

**Gap Lock在InnoDB的唯一作用就是防止其他事务的插入操作，以此防止幻读的发生。**

 **Innodb自动使用间隙锁的条件：
（1）必须在Repeatable Read级别下
（2）检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）**



**间隙锁在InnoDB的唯一作用就是防止其它事务的插入操作，以此来达到防止幻读的发生，所以间隙锁不分什么共享锁与排它锁。 默认情况下，InnoDB工作在Repeatable Read隔离级别下，并且以\**\*Next-Key Lock\**\*的方式对数据行进行加锁，这样可以有效防止\**\*幻读\**\*的发生。\**\*Next-Key Lock\**\*是行锁与间隙锁的组合，当对数据进行条件，范围检索时，对其范围内也许并存在的值进行加锁！当查询的索引含有唯一属性（唯一索引，主键索引）时，Innodb存储引擎会对next-key lock进行优化，将其降为record lock,即仅锁住索引本身，而不是范围！若是普通辅助索引，则会使用传统的next-key lock进行范围锁定！**

**要禁止间隙锁的话，可以把隔离级别降为Read Committed，或者开启参数\*innodb_locks_unsafe_for_binlog\*。**

 

**对于快照读来说，幻读的解决是依赖mvcc解决。而对于当前读则依赖于gap-lock解决。**





保证事务一致性和持久性的底层原理，redo log 和undo log



具体信息:https://segmentfault.com/a/1190000023827696



简单来说，就是事务的sql，会把事务中改动的数据，记录到redo log中，然后一次性刷到磁盘中去。

事务中，记录修改前的数据，如果事务回滚了，就按照undo log中记录的数据，回滚事务。



### mysql的事务嵌套。

```sql
START TRANSACTION;

INSERT INTO `user` (`name`, `gender`) VALUES ('Tom', 3);

START TRANSACTION;#当执行此语句再次开启事务时，会隐式提交外层事务。Tom的数据，已经被写到数据库了。外层事务已经结束了

INSERT INTO `user` (`name`, `gender`) VALUES ('Lucy', 4);

ROLLBACK;
COMMIT;
COMMIT;
```

